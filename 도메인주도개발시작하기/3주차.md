# 4장 리포지터리와 모델 구현

## 4.1 JPA를 이용한 리포지터리 구현

애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법이 다르기 때문에 모든 구현 기술에 대해 알아볼 수는 없다.

데이터 보관소로 RDBMS를 사용할 때, 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 ORM 만한 것이 없기에 자바의 ORM 표준인 JPA를 이용해서 살펴본다.

### 4.1.1 모듈 위치

리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

### 4.1.2 리포지터리 기본 기능 구현

리포지터리가 제공하는 기본 기능은 (1) ID로 애그리거트 조회, (2) 애그리거트 저장 이다.

인터페이스는 애그리거트 루트를 기준으로 작성한다.

애그리거트를 수정한 결과를 저장소에 반영하는 메소드를 추가할 필요는 없다. JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문이다.

## 4.2 Spring Data JPA를 이용한 리포지터리 구현

Spring Data JPA는 다음 규칙에 따라 작성한 인터페이스를 찾아서 인터페이스를 구현한 스프링 Bean 객체를 자동으로 등록한다.
* `org.springframework.data.repository.Repository<T, ID>` 인터페이스 상속
* T는 엔티티 타입을 지정하고 ID는 식별자 타입을 지정

Spring Data JPA를 사용하려면 지정한 규칙에 맞게 메소드를 작성해야 한다.

* 저장하는 메소드
  * `Entity save(Entity entity)`
  * `void save(Entity entity)`
* 식별자를 이용해서 조회하는 메소드
  * `Entity findById(EntityNo id)`
  * `Optional<Entity> findById(EntityNo id)`
* 특정 프로퍼티를 이용해서 조회하는 메소드
  * `List<Entity> findByProperty(PropertyType property)`
* 중첩 프로퍼티도 가능하다. PropertyType 객체의 subType 프로퍼티가 파라미터와 같은 Entity를 조회한다.
  * `List<Entity> findByPropertySubType(SubType subType)`
* 삭제하는 메소드
  * `void delete(Entity entity)`
  * `void deleteById(EntityNo id)`

## 4.3 매핑 구현

### 4.3.1 엔티티와 밸류 기본 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.
* 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정한다.

한 테이블에 엔티티와 밸류 데이터가 같이 있다면
* 밸류는 `@Embeddable`로 매핑 설정한다.
* 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정한다.

`@Embeddable` 타입에 설정한 칼럼 이름과 실제 칼럼 이름이 다르다면 `@AttributeOverrides`를 이용해서 프로퍼티와 매핑할 칼럼 이름을 변경할 수 있다.

### 4.3.2 기본 생성자

엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.

JPA에서 `@Entity`와 `@Embeddable`로 클래스를 매핑하려면 기본생성자를 제공해야 한다. DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문이다.

기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용하므로 다른 코드에서 사용하지 못하도록 `protected`로 선언한다.

### 4.3.3 필드 접근 방식 사용

JPA는 필드와 메소드의 두 가지 방식으로 매핑을 처리할 수 있다.

메소드 방식을 활용하려면 get/set 메소드를 구현해야 한다. <br>
공개 get/set 메소드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다. 특히 set 메소드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있다.

객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메소드를 구현하지 말아야 한다. <br>
`@Access(AccessType.FIELD)`를 활용한다.

JPA 구현체인 하이버네이트는 @Access를 이용해서 명시적으로 접근 방식을 지정하지 않으면 @Id나 @EmbeddedId가 어디에 위치했느냐에 따라 접근 방식을 결정한다. 필드에 위치하면 필드 접근 방식, get()에 위치하는 메소드 접근 방식을 선택한다.

### 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리

밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때가 있다.

이런 경우 `@Embeddable`로는 처리할 수 없고 `AttributeConverter`를 사용해야 한다. <br>
`AttributeConvert<ValueType, DBType>`을 구현한 클래스를 선언하여 활용한다. 해당 클래스는 `@Converter`를 적용한다. `@Converter`의 `autoApply` 속성을 true로 지정하면 모든 ValueType의 프로퍼티에 대해 자동으로 Converter를 적용한다.

### 4.3.5 밸류 컬렉션: 별도 테이블 매핑

`@ElementCollection`과 `@CollectionTable`을 함께 사용한다.

`@OrderColumn` 을 이용해서 지정한 칼럼에 리스트의 인덱스 값을 저장한다.

### 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑

밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다.

`AttributeConverter`를 활용하며, 집합을 위한 밸류 타입을 추가로 작성해야 한다.

### 4.3.7 밸류를 이용한 ID 매핑

식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수 있다.

밸류 타입을 식별자로 매핑하면 `@Id` 대신 `@EmbeddedId`를 사용한다.

JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 해당 인터페이스를 상속받아야 한다.

> 왜 Serializable 타입이어야 하나?
> 직렬화는 JVM 메모리에 상주 되어 있는 객체 데이터를 그대로 영속화할 때 사용된다.
> 서버가 다중화 되어 있고 세션 클러스터링 하는 환경에서 도메인 객체가 세션에 저장된다면 해당 도메인 객체가 Serializable 인터페이스를 구현해야 정상적으로 세션을 저장/불러오기 할 수 있다.

밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.

### 4.3.8 별도 테이블에 저장하는 밸류 매핑

애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류다. 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다. 

밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다. 특히 자신만의 독자적인 라이프사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다. <br>
애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지를 확인하는 것이다. 하지만 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안된다. 별도 테이블로 저장하고 테이블에 PK가 있다고 해도 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문이다.

밸류는 `@Embeddable`로 매핑하고, 밸류를 매핑한 테이블을 지정하기 위해 `@SecondaryTable`과 `@AttributeOverride`를 사용한다.

### 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있다.

JPA는 @Embeddable 타입의 클래스 상속 매핑을 지원하지 않는다. 상속 구조를 갖는 밸류타입을 사용하려면 @Embeddable 대신 @Entity를 이용해서 상속 매핑으로 처리해야 한다.

한 테이블에 상위 클래스와 그 하위 클래스를 매핑하므로 다음 설정을 사용한다.
* `@Inheritance` 적용
* strategy 값으로 `SINGLE_TABLE` 사용
* `@DiscriminatorColumn` 이용하여 타입 구분용으로 사용할 칼럼 지정

@Entity에 대한 @OneToMany 매핑에서 컬렉션의 clear() 메소드를 사용하면 삭제 과정이 효율적이지 않다. N+1 문제 발생
애그리거트의 특성을 유지하면서 이 문제를 해소하려면 상속을 포기하고 @Embeddable로 매핑된 단일클래스로 구현해야 한다.

### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

3장에서 애그리거트 간 집합 연관은 성능 상의 이유로 피해야 한다고 했다. 그럼에도 불구하고 사용해야 한다면 ID 참조를 이용한 단방향 집합 연관을 적용해볼 수 있다.

ID 참조를 이용한 애그리거트 간 단방향 M-N 연관은 밸류 컬렉션 매핑과 동일한 방식으로 설정한다. 차이점이 있다면 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다는 점이다.

## 4.4 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.

FetchType.EAGER로 즉시로딩을 설정하면 애그리거트 루트를 구할 때 연관된 구성요소를 DB에서 함께 읽어온다.

애그리거트는 개념적으로 하나여야 한다. 하지만 루트 엔티티를 로딩하는 싲머에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다. <br>
애그리거트가 완전해야 하는 이뉴는 두 가지다. (1) 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 떄문이고, (2) 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다. <br>
상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없다. 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.

## 4.5 애그리거트의 영속성 전파

애그리거트가 완전한 상태여야 한다는 것은 애그리거트를 조회할 때 뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다. @Embeddable 매핑은 함께 저장되고 삭제되므로 cascade 속성은 추가로 설정하지 않아도 되고, @Entity 매핑은 속성을 사용해서 함께 처리되도록 설정해야 한다.

## 4.6 식별자 생성 기능

식별자 생성방식
* 사용자가 직접 생성
* 도메인 로직으로 생성
* DB를 이용한 일련번호 생성

식별자 생성 규칙이 있다면 엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야 한다.

## 4.7 도메인 구현과 DIP

DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성을 가져가면서 구조적인 유연함은 어느정도 유지했다. 복잡도를 높이지 않으면서 기술에 따른 구현 제약이 낮다면 합리적인 선택이라고 생각한다.

# 5장 Spring Data JPA를 이용한 조회 기능

## 5.1 시작에 앞서

CQRS, 명령모델과 조회모델을 분리하는 패턴. 명령 모델은 상태를 변경하는 기능을 구현할 때 사용하고 조회 모델은 데이터를 조회하는 기능을 구현할 때 사용한다.

조회 모델을 구현할 때 다양한 기술을 사용한다. 모든 DB 연동 코드를 JPA만 사용해서 구현해야 한다고 생각하지는 말 것.

## 5.2 검색을 위한 스펙

검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것이 스펙 Specification 이다. <br>
스펙은 애그리거트가 특정 조건을 충족하는지를 검사할 때 사용하는 인터페이스다.

## 5.3 Spring Data JPA를 이용한 스펙 구현

스펙 인터페이스에서 제네릭 타입 파라미터 T는 JPA 엔티티 타입을 의미한다.

스펙 구현 클래스를 개별적으로 만들지 않고 별도 클래스에 스펙 생성 기능을 모아도 된다.

## 5.4 리포지터리/DAO에서 스펙 사용하기

스펙을 충족하는 엔티티를 검색하고 싶다면 findAll()을 사용하면 된다. 해당 메소드는 스펙 인터페이스를 파라미터로 갖는다.

## 5.5 스펙 조합

스펙 인터페이스는 스펙을 조합할 수 있는 두 메소드를 제공한다. `and()`와 `or()`이다.

개별 스펙 조건마다 변수를 선언하지 않고 체이닝 메소드로 사용하면 불필요한 변수 사용을 줄일 수 있다.

스펙 인터페이스는 `not()`도 제공한다. 정적 메소드로 조건을 반대로 적용할 때 사용한다.

`where()`은 스펙 인터페이스의 정적 메소드로 null을 전달하면 아무 조건도 생성하지 않는 스펙 객체를 리턴하고 null이 아니면 인자로 받은 스펙 객체를 그대로 리턴한다.

## 5.6 정렬 지정하기

Spring Data JPA는 두 가지 방법을 사용해서 정렬을 지정할 수 있다.
* 메소드 이름에 OrderBy를 사용해서 정렬 기준 지정
* Sort를 인자로 전달

특정 프로퍼티로 조회하는 `find` 메소드는 이름 뒤에 `OrderBy`를 사용해서 정렬 순서를 지정할 수 있다. <br>
두 개 이상의 프로퍼티에 대한 정렬 순서를 지정할 수도 있다. `OrderByADescBAsc`와 같이 사용한다.

Spring Data JPA는 정렬 순서를 지정할 때 사용할 수 있는 Sort 타입을 제공한다. <br>
find() 마지막 파라미터로 Sort를 추가한다. Spring Data JPA는 파라미터로 전달받은 Sort를 사용해서 알맞게 정렬 쿼리를 생성한다.

## 5.7 페이징 처리하기

Spring Data JPA는 페이징 처리를 위해 Pageable 타입을 이용한다. Sort 타입과 마찬가지로 find()에 Pageable 타입 파라미터를 사용하면 페이징을 자동으로 처리해준다.

Pageable을 사용하는 메소드의 리턴 타입이 Page일 경우 Spring Data JPA는 목록 조회 쿼리와 함께 COUNT 쿼리도 실행해서 조건에 해당하는 데이터 개수를 구한다.

처음부터 N개의 데이터가 필요하다면 Pageable을 사용하지 않고 findFirstN 형식의 메소드를 사용할 수도 있다. <br>
First대신 Top을 사용해도 된다. 뒤에 N이 없으면 한 개 결과만 리턴한다.

## 5.8 스펙 조합을 위한 스펙 빌더 클래스

스펙 빌더를 사용하면 if 블록을 사용하지 않고 메소드를 사용해서 조건을 표현하고 메소드 호출 체인으로 연속된 변수 할당을 줄여 코드 가독성을 높이고 구조가 단순해진다.

`and()`, `ifHasText()`, `ifTrue()` 등의 메소드를 사용한다.

## 5.9 동적 인스턴스 생성

JPA는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공한다.

select 절에 new 키워드와 생성할 인스턴스의 완전한 클래스 이름을 지정하고 괄호 안 생성자에 인자로 전달할 값을 지정한다.

조회 전용 모델을 만드는 이유는 표현 영역을 통해 사용자에게 데이터를 보여주기 위함이다.

동적 인스턴스의 장점은 JPQL을 그대로 사용하므로 객체 기준으로 쿼리를 작성하면서도 동시에 지연/즉시 로딩과 같은 고민 없이 원하는 모습으로 데이터를 조회할 수 있다는 점이다.

## 5.10 하이버네이트 @Subselect 사용

`@Subselect`는 쿼리 결과를 `@Entity`로 매핑할 수 있는 유용한 기능이다.

`@Immutable`, `@Subselect`, `@Synchronize는` 하이버네이트 전용 어노테이션인데 이 태그를 사용하면 테이블이 아닌 쿼리 결과를 `@Entity`로 매핑할 수 있다.

`@Subselect`는 조회 쿼리를 값으로 갖는다. 하이버네이트는 이 select 쿼리의 결과를 매핑할 테이블처럼 사용한다.

뷰를 수정할 수 없듯이 `@Subselect`로 조회한 `@Entity` 역시 수정할 수 없다. 실수로 `@Subselect`를 이용한 `@Entity`의 매핑 필드를 수정하면 하이버 네이트는 변경 내역을 반영하는 update 쿼리를 실행한다. 그런데 매핑 한 테이블이 없으므로 에러가 발생한다. 이 문제를 방지하기 위해 `@Immutable`을 사용한다. `@Immutable`을 사용하면 하이버네이트는 해당 엔티티의 매핑 필드/프로퍼티가 변경되도 DB에 반영하지 않고 무시한다.

상태를 변경한 뒤 조회하는 경우, 하이버네이트는 트랜잭션을 커밋하는 시점에 변경사항을 DB에 반영하므로 변경내역이 아직 테이블에 반영하지 않은 상태에서 테이블을 조회할 수 있다. <br>
이 문제를 해소하기 위한 용도로 사용한 것이 `@Synchronize`이다. 해당 엔티티와 관련된 테이블 목록을 명시한다. 하이버네이트는 엔티티를 로딩하기 전에 지정한 테이블과 관련된 변경이 발생하면 플러시를 먼저한다.