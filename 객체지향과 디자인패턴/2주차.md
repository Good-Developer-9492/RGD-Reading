# 2주차

날짜: 2022년 10월 1일

책 읽어와서 만나고 토론

## 재사용: 상속보단 조립

- 상속과 재사용
    - 상속을 통한 재사용의 단점
        - 상위 클래스 변경의 어려움
        - 클래스의 불필요한 증가
        - 상속의 오용
            - 자바의 기본 라이브러리를 상속받아서 사용하는 경우
    - **상속은 Is-A 관계가 성립할 때에만 사용해야 한다.**
- 조립을 이용한 재사용
    - 런타임에 조립 대상 객체를 교체할 수 있는 장점이 있다.
    - 위임 → 내가 할 일을 다른 객체에게 넘긴다는 의미
        - 조립 vs 위임
            - 조립은 하나의 클래스에서 다른 여러 개의 클래스의 기능을 조합하여 특정 기능을 구현하는 것
            - 위임은 하나의 클래스에서 다른 하나의 클래스의 기능을 사용하여 특정 기능의 동작을 위임하는 것
    - 상속은 언제 사용해야 하는가?
        - 재사용이라는 관점이 아닌 기능의 확장이라는 관점에서 상속을 적용해야 한다.
        - 하위 클래스로 내려갈수록 상위 클래스의 기본적인 기능을 그대로 유지하면서, 그 기능을 확장해 나간다는 점

# Part 02 - 설계 원칙 / DI와 서비스 로케이터

## 설계 원칙 : SOLID

- **SRP 단일 책임 원칙 (Single Responsibility Principle)**
    - 클래스는 단 한 개의 책임을 가져야 한다.
        - 클래스가 여러 책임을 가지게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에 한 개의 책임만을 가져야 한다.
        - 한 개의 책임에 대한 정의가 명확하지 않고, 책임을 도출하기 위해서는 다양한 경험이 필요하기 때문에 가장 어려운 원칙이다.
    - 개발할 때 해당 클래스 및 메소드가 한 개의 책임만을 가지고 있는지, 변화가 발생할 요소가 하나인지 계속 생각하면서 개발!
- **OCP 개방 폐쇄 원칙 (Open-Closed Principle)**
    - 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
    - 구현 로직이 변경되어도 사용하는 부분에서는 변경되지 않아야 한다.
    - 개방 폐쇄 원칙을 구현하는 또 다른 방법은 상속을 이용하는 것이다.
        - 상위 클래스에 파라미터, 리턴타입 등이 고정되어 있으니 원칙을 지킬 수 있다.
    - instanceof, if-else를 사용하는 것이 OCP가 깨질 때의 주요 증상이다.
    - 개방 폐쇄 원칙은 유연함에 대한 것이다.
        - 기존 기능을 확장하기 위해 기존 코드를 수정해 주어야 한다면, 새로운 기능을 추가하는 것이 점점 힘들어진다.
        - 변화되는 부분을 추상화하지 못하면 개방 폐쇄 원칙을 지킬 수 없게 되어, 시간이 흐를수록 기능 변경이나 확장을 어렵게 만든다.
- **LSP 리스코프 치환 원칙 (Liskov Substitution Principle)**
    - 개방 폐쇄 원칙을 받쳐 주는 다형성에 관한 원칙을 제공한다.
        - LSP가 제대로 지켜지지 않으면 다형성에 기반한 OCP 역시 지켜지지 않는다.
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
        - OCP에서 말했던 것처럼, 상위 클래스에 파라미터, 리턴타입이 고정되어 있으므로
    - 직사각형 - 정사각형 문제
        - 수학적으로 직사각형은 정사각형이 아니지만, 정사각형은 직사각형이다.
        - 개념적으로 상속 관계에 있는 것처럼 보일지라도 실제 구현에서는 상속 관계가 아닐 수도 있다.
- **ISP 인터페이스 분리 원칙 (Interface Segregation Principle)**
    - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    - 용도에 맞게 인터페이스를 분리하는 것은 단일 책임 원칙과도 연결된다.
        - 여러 용도를 하나의 인터페이스로 사용하지 말아야 한다.
        → 인터페이스를 분리하는 기준이 클라이언트가 되어야 한다.
- **DIP 의존 역전 원칙 (Dependency Inversion Principle)**
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
        - 고수준 모듈 → 어떤 의미 있는 단일 기능을 제공하는 모듈
        - 저수준 모듈 → 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
    - 원하는 것은 저수준 모듈이 변경되더라도 고수준 모듈은 변경되지 않는 것
        - 저수준 모듈이 고수준 모듈을 의존하게 만들어서 해결 (추상화)
    - 의존 역전 원칙은 개방 폐쇄 원칙을 클래스 수준 뿐만 아니라 패키지 수준까지 확장시켜주는 디딤돌이 된다.

## **DI**와 서비스 로케이터

- 어플리케이션 영역과 메인 영역
    - 실제 로직에 필요한 객체를 구하는 방식이 필요하다.
        - DI, 서비스 로케이터와 같은 방식이 존재한다.
        - 서비스 로케이터 → 사용할 객체를 제공하는 책임을 갖는 객체
- **DI(Dependency Injection)을 이용한 의존 객체 사용**
    - 필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어 주는 방식
    - 생성자 방식
        - 생성자를 통해서 필요한 의존 객체를 전달받기 때문에, 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있다.
        - 사용하지 않더라도 가지고 있을 수 있음
    - Setter 방식
        - 객체를 생성한 뒤에 의존 객체를 주입한다.
            - 의존 객체를 설정하지 못한 상태에서 객체를 사용할 수 있게 되므로 객체의 메소드를 실행하는 과정에서 Exception이 발생할 수 있다.
        - 메소드를 봐야 의존관계를 알 수 있기 때문에 필요한 시점에 적용할 수 있음.
- 서비스 로케이터