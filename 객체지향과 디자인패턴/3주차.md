# 3주차

날짜: 2022년 10월 15일

# Part 03 - 주요 디자인 패턴

- 디자인 패턴이란?
    - 디자인 패턴을 통해 습득할 수 있는 이득
        - 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있다.
        - 각 패턴의 장단점을 통해서 설계를 선택하는데 도움을 얻을 수 있다.
        - 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있다.
    - GoF (Gang of Four) 참고
- 전략 패턴
    - 알고리즘을 추상화하고 있는 인터페이스를 전략이라고 부르고 기능 자체의 책임을 갖고 있는 클래스를 콘텍스트라고 부르는데, **특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법**
    - 콘텍스트는 사용할 전략을 직접 선택하지 않는다.
    - 장점
        - 코드 이해를 높이고 코드 응집도를 높여주는 효과가 있다.
        - 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다.
    - 완전히 동일한 기능을 제공하지만 성능의 장단점에 따라 알고리즘을 선택해야 하는 경우에 활용
- 템플릿 메소드 패턴
    - 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴
    - **상위 클래스에서는 흐름을 제어하고 하위 클래스는 각 흐름에 사용되는 메소드들을 구현한다.**
    - 상위클래스는 abstract vs interface 중 어떤 것으로 선언해야 하는가?
        - 추상 클래스는 is-a관계, 인터페이스는 has-a 관계일 때 사용하는 것을 유의
        - 템플릿 메소드에서는 상위클래스가 흐름을 제어하는 것이 주 목적이므로 추상클래스를 활용하는 것이 좋아보임.
    - in Spring
        - FrameworkServlet
            - processRequest() 에서 흐름을 제어
            - doService()를 abstract로 선언
        - DispatcherServlet
            - FrameworkServlet을 상속
            - doService()를 구현
- 상태 패턴
    - 기능이 상태에 따라 다르게 동작해야할 때 사용할 수 있는 패턴
        - 상태가 많아질수록 복잡해지는 조건문이 여러 코드에서 중복해서 출현하고, 그만큼 코드 변경을 어렵게 만들기 때문에 나타난 패턴
    - 장점
        - 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다.
    - 상태 변경을 하는 주체
        - 콘텍스트
            - 비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리하다.
            - 상태 종류가 지속적으로 변경되거나 상태 변경 규칙이 자주 바뀔 경우 콘텍스트의 상태 변경 처리 코드가 복잡해질 가능성이 높기 때문
        - 상태 객체
            - 콘텍스트에 영향을 주지 않음녀서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있다.
            - 상태 구현 클래스가 많아질수록 상태 변경 규칙을 파악하기가 어려워진다.
            - 한 상태 클래스에서 다른 상태 클래스에 대한 의존이 발생한다.
                - 첫 번째 상태 클래스의 메소드를 실행 이후 다른 상태로 변경될 수 있기 때문에
    - vs 전략 패턴
        - [https://jaeseongdev.github.io/development/2021/02/13/전략_패턴과_상태_패턴의_차이점/](https://jaeseongdev.github.io/development/2021/02/13/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4%EA%B3%BC_%EC%83%81%ED%83%9C_%ED%8C%A8%ED%84%B4%EC%9D%98_%EC%B0%A8%EC%9D%B4%EC%A0%90/)
        전략패턴은 인스턴스 생성 후, 상태가 거의 바뀌지 않는 경우
        상태패턴은 인스턴스 생성 후, 상태가 빈번히 바뀌는 경우
- 데코레이터 패턴
    - 상속이 아닌 위임을 통한 기능 확장
    기존 기능에 새로운 기능을 추가해주는 객체를 데코레이터라고 한다.
        - 각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에,
        각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어 준다.
    - 순서가 있다!
        - 순서 파악 및 변경이 쉽다.
    - 주 객체인 최종 결과물은 인터페이스로 선언해야 한다.
    - in Spring
        - 트랜잭션 처리를 위해 사용한다.
        - AOP의 부가적인 기능을 확장하는 경우에 활용한다.
- 프록시 패턴
    - 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해주는 패턴
    - 장점
        - 불필요하게 메모리를 낭비하는 상황을 방지할 수 있다.
    - 가상 프록시
        - 필요한 순간에 실제 객체를 생성해 주는 프록시
    - 보호 프록시
        - 실제 객체에 대한 접근을 제어하는 프록시
    - 원격 프록시
        - 자바의 RMI처럼 다른 프로세스에 존재하는 객체에 접근할 때 사용되는 프록시
    - in Spring
        - AOP
        - Spring JPA에서 Lazy Loading에 활용
        - 트랜잭션 처리
- 어댑터 패턴
    - 클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴
    - 예시
        - MultiValueMap과 Map을 이어주는 MultiValueMapAdapter
    - vs Delegate 패턴 (TODO)
- 옵저버 패턴
    - 한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에 통지하고 싶을 때 사용되는 패턴
    - 주제 객체
        - 옵저버 목록을 관리하고, 옵저버를 등록하고 제거할 수 있는 메소드를 제공한다.
        - 상태의 변경이 발생하면 등록된 옵저버에 변경 내역을 알린다.
    - 옵저버 객체
        - Email, SMS, Slack 등 옵저버 객체들
    - 장점
        - 주제 클래스 변경 없이 상태 변경을 통지 받을 옵저버를 추가할 수 있다는 점
    - 구현 고려 사항
        - 옵저버에 통지하는 시점을 결정하는 주체가 누가 되느냐
        - 옵저버 인터페이스의 분리
            - 모든 종류의 상태 변경을 하나의 옵저버 인터페이스로 처리할 경우 거대해 지기 때문
        - 통지 시점에서의 주제 객체 상태
            - 옵저버 notify 이후 값이 바뀌는 상황 방지
            - 템플릿 메소드 활용해서 흐름 제어
        - 옵저버 객체의 실행 제약 조건
            - 실행 제한에 대한 명확한 기준이 필요 
            (긴 작업을 수행해야 할 경우 별도 쓰레드로 실행해야 한다는 제약 조건 등)
- 미디에이터 패턴
- 파사드 패턴
- 추상팩토리 패턴
- 컴포지트 패턴
- 널 객체 패턴